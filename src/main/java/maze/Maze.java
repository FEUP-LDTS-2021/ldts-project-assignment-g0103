package maze;

import com.googlecode.lanterna.SGR;
import com.googlecode.lanterna.TerminalPosition;
import com.googlecode.lanterna.TerminalSize;
import com.googlecode.lanterna.TextColor;
import com.googlecode.lanterna.graphics.TextGraphics;

import element.Element;
import element.dynam.Hero;
import element.position.Position;
import element.position.PositionInterface;
import element.Static.*;
import game.GameInterface;

import java.util.*;

/**
 * Maze class which contains the elements that make up the game, this includes, but is not limited to, static elements such as hero, path, walls, other special
 * game objects and the actual maze in matrix form, generated from the MazeGenerator class. This class is also responsible for managing the directional inputs received by the
 * player and verifying the state of the game.
 *
 * @author Eduardo Correia
 * @author Alberto Serra
 * @author Jos√© Carvalho
 */
public class Maze implements MazeInterface {
    final private int xIncr = 50;
    final private int yIncr = 15;
    private int counter;
    private Position begin;
    private final Position ending;
    private final boolean init;
    private final GameInterface game;
    private int[][] maze;
    private final int dim;
    private final Hero hero;
    private final List<StaticElement> staticElems;
    private final List<Heart> hp;
    private final Queue<Path> path;
    final private String backgroundcolor = "BLACK";
    //todo change hero constructor to accept starting hp as a variable and the correspondent tests
    private final int heroHealth = 5;


    /**
     * Constructor for the maze class. Requires a game class in which the maze shall be used and an appropriate dimension.
     * @param game game class in which the maze is to be used in.
     * @param dim dimension integer which dictates the maze's size.
     */
    public Maze(GameInterface game, int dim) {
        //Initialize Variables
        this.game = game;
        this.dim = dim;
        this.begin = new Position(1 + xIncr, 1 + yIncr);
        this.ending = new Position(dim - 2 + xIncr, dim - 2 + yIncr);
        init = false;
        counter = 0;
        hp = new ArrayList<>();
        staticElems = new ArrayList<>();
        path = new LinkedList<>();
        hero = new Hero(begin, "GREEN", SGR.BORDERED, "@");
        hero.setHealth(heroHealth);

        //Generate correct maze
        do {
            MazeGenerator gen = new MazeGenerator(dim - 2);
            gen.generateMaze();
            maze = gen.getIntMaze();
        } while (maze[dim - 3][dim - 3] == 0);

        //Create bigger matrix with outer walls
        maze = load_walls(maze, dim);
        //Create elements and insert them to element list
        createElements();

    }

    /**
     * Function to encapsulate the raw integer maze matrix in the value 0 (which corresponds to a Wall).
     * @param map raw integer maze generated by the maze generator.
     * @param dim integer dimension for the output maze.
     * @return returns a new raw integer maze in which the outer layers have the value of 0.
     */
    static private int[][] load_walls(int[][] map, int dim) {
        int[][] maze = new int[dim][dim];
        for (int i = 1; i < dim - 1; i++) {
            for (int j = 1; j < dim - 1; j++) {
                if (map[i - 1][j - 1] != 0) maze[i][j] = map[i - 1][j - 1];
            }
        }
        return maze;
    }

    /**
     * Function to create the elements that exist within the maze.
     */
    private void createElements() {
        createHpBar();
        createWalls();
        createTrophy();
    }

    /**
     * Returns the dimension value.
     * @return dimension integer.
     */
    public int getDim() {
        return dim;
    }

    /**
     * Checks the tile that the player is attempting to move to and runs code accordingly.
     * @param position position to which the player is attempting to move to.
     */
    public void checkTile(PositionInterface position) {
        if (position.equals(ending)) {
            winGame();
            return;
        } else {
            if (checkRedPath(position)) {
                hero.heroTakesDamage();
                loadHearts();
                if (hero.isDead()) gameOver();
                return;
            }
            if (!checkWall(position)) {
                moveHero(position);
            }
        }
    }

    /**
     * Moves the Hero to a certain position.
     * @param position
     */
    public void moveHero(PositionInterface position) {
        counter++;
        if(!checkPath(hero.getPosition()) && !checkRedPath(hero.getPosition()))
            path.add(new Path(hero.getPosition(), "YELLOW", SGR.BOLD, "O"));
        hero.setPosition(position);
        if (counter == 2) {
            PositionInterface pathPosition = path.remove().getPosition();
            staticElems.add(new RedPath(pathPosition, "RED", SGR.BOLD, "O"));
            counter = 0;
        }
    }

    /**
     * Sets the game state to won.
     */
    public void winGame() {
        game.setState(5);
    }

    /**
     * Sets the game state to lost.
     */
    public void gameOver() {
        game.restartGame();
        game.setState(0);
        hero.setHealth(heroHealth);
    }

    /**
     * Receives a key input from the player, check if it's an arrow key and run the appropriate code.
     * @param key key input from the player.
     */
    public void processKey(com.googlecode.lanterna.input.KeyStroke key) {
        System.out.println(key);
        switch (key.getKeyType()) {
            case ArrowUp -> checkTile(hero.moveUp());
            case ArrowDown -> checkTile(hero.moveDown());
            case ArrowLeft -> checkTile(hero.moveLeft());
            case ArrowRight -> checkTile(hero.moveRight());
        }
    }

    /**
     * Checks if there's a Wall object at a given position
     * @param position position to check
     * @return boolean corresponding to the existence of a Wall object
     */
    private boolean checkWall(PositionInterface position) {
        for (Element tile : staticElems) {
            if (tile instanceof Wall)
                if (tile.getPosition().equals(position)) return true;
        }
        return false;
    }

    /**
     * Checks if there's a RedPath object at a given position.
     * @param position position to check.
     * @return boolean corresponding to the existence of a RedPath object.
     */
    private boolean checkRedPath(PositionInterface position) {
        for (Element tile : staticElems) {
            if (tile instanceof RedPath)
                if (tile.getPosition().equals(position)) return true;
        }
        return false;
    }

    /**
     * Checks if there's a Path object at a given position.
     * @param position position to check.
     * @return boolean corresponding to the existence of a Path object.
     */
    private boolean checkPath(PositionInterface position) {
        for (Element tile : path) {
            if (tile instanceof Path)
                if (tile.getPosition().equals(position)) return true;
        }
        return false;
    }

    /*
   //Generic Implementation of checkElement
   private <T> boolean checkElement (PositionInterface position) {
        for (Element tile : elements) {
            if (tile instanceof T)
                if (tile.getPosition().equals(position)) return true;
        }
        return false;
    }
*/

    /**
     * Creates a Trophy at the ending position of the maze.
     */
    private void createTrophy() {
        staticElems.add(new Trophy(ending, "#F3CA28", SGR.BOLD, "$"));
    }

    /**
     * Creates walls objects corresponding to where the value 0 exists in the raw integer maze.
     */
    private void createWalls() {
        for (int i = 0; i < dim; i++) {
            for (int j = 0; j < dim; j++) {
                if (maze[i][j] == 0)
                    staticElems.add(new Wall(new Position(i + xIncr, j + yIncr), "#FFFFFF", SGR.BOLD, "#"));
            }
        }
    }

    /**
     * Creates an Hpbar object at the upper-left corner of the terminal.
     */
    private void createHpBar() {
        int xsize = hero.getHealth() + 2;
        int ysize = 3;
        for (int i = 0; i < xsize; i++) {
            for (int j = 0; j < ysize; j++) {
                if (i == 0 || i == xsize - 1 || j == 0 || j == ysize - 1)
                    staticElems.add(new HpBar(new Position(i + 1, j + 1), "#FFFFFF", SGR.BOLD, "."));
            }
        }
        loadHearts();
    }

    //TODO change hearts to be stored to a stack instead.
    /**
     * Creates hearts objects corresponding to the current hp of the Hero object.
     */
    private void loadHearts() {
        hp.clear();
        for (int i = 1; i <= hero.getHealth(); i++) {
            hp.add(new Heart(new Position(i + 1, 2), "#FF0000", SGR.BOLD, "X"));
        }
    }

    /**
     * Draws the maze objects on the lanterna screen.
     * @param screen lanterna screen to draw to.
     */
    public void draw(TextGraphics screen) {
        screen.setBackgroundColor(TextColor.Factory.fromString(backgroundcolor));
        screen.fillRectangle(new TerminalPosition(xIncr, yIncr), new TerminalSize(dim, dim), ' ');
        for (Element element : hp)
            element.draw(screen);
        for (Element element : staticElems)
            element.draw(screen);
        for (Path tile : path)
            tile.draw(screen);
        loadHearts();
        hero.draw(screen);
    }

    /**
     * Transforms the raw integer maze to string form.
     * @return raw integer maze in string form.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int[] row : maze) {
            sb.append(Arrays.toString(row) + "\n");
        }
        return sb.toString();
    }
}

